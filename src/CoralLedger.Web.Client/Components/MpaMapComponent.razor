@using System.Text.Json
@using NetTopologySuite.Geometries
@using NetTopologySuite.IO
@using Mapsui.Extensions
@using Mapsui.Styles
@inject HttpClient Http

<div class="mpa-map-container" style="height: 100%; width: 100%; position: relative;">
    @if (_loading)
    {
        <div class="loading-overlay">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading map...</span>
            </div>
        </div>
    }
    <MapControl @ref="_mapControl" Map="_map" />

    @if (_showLegend)
    {
        <div class="map-legend">
            <h6>Protection Levels</h6>
            <div class="legend-item">
                <span class="legend-color" style="background-color: #dc3545;"></span>
                <span>No-Take Zone</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background-color: #fd7e14;"></span>
                <span>Highly Protected</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background-color: #0dcaf0;"></span>
                <span>Lightly Protected</span>
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background-color: #6c757d;"></span>
                <span>Minimal Protection</span>
            </div>
            @if (ShowFishingEvents)
            {
                <hr class="my-2" />
                <h6>Fishing Activity</h6>
                <div class="legend-item">
                    <span class="legend-dot" style="background-color: #dc3545;"></span>
                    <span>Last 7 days</span>
                </div>
                <div class="legend-item">
                    <span class="legend-dot" style="background-color: #fd7e14;"></span>
                    <span>7-14 days ago</span>
                </div>
                <div class="legend-item">
                    <span class="legend-dot" style="background-color: #ffc107;"></span>
                    <span>14-30 days ago</span>
                </div>
                <div class="legend-item">
                    <span class="legend-dot" style="background-color: #6c757d;"></span>
                    <span>Older</span>
                </div>
            }
        </div>
    }

    @if (!string.IsNullOrEmpty(_selectedMpaName))
    {
        <div class="map-info-popup">
            <strong>@_selectedMpaName</strong>
            <br />
            <small>Click for details</small>
        </div>
    }

    @if (_selectedFishingEvent is not null)
    {
        <div class="map-info-popup fishing-event-popup">
            <strong><i class="bi bi-water"></i> Fishing Event</strong>
            <hr class="my-1" />
            <small class="d-block"><strong>Vessel:</strong> @_selectedFishingEvent.VesselId</small>
            <small class="d-block"><strong>Date:</strong> @_selectedFishingEvent.StartTime.ToString("MMM d, yyyy")</small>
            @if (_selectedFishingEvent.DurationHours.HasValue)
            {
                <small class="d-block"><strong>Duration:</strong> @_selectedFishingEvent.DurationHours.Value.ToString("F1") hours</small>
            }
        </div>
    }
</div>

<style>
    .mpa-map-container {
        position: relative;
        min-height: 500px;
    }

    .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    .map-legend {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: white;
        padding: 12px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        z-index: 999;
    }

    .map-legend h6 {
        margin-bottom: 8px;
        font-weight: 600;
        color: #333;
    }

    .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 4px;
        font-size: 0.85rem;
    }

    .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        margin-right: 8px;
        border: 1px solid rgba(0,0,0,0.2);
    }

    .legend-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px;
        border: 2px solid white;
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }

    .fishing-event-popup {
        background: linear-gradient(135deg, #e3f2fd 0%, #ffffff 100%);
        border-left: 4px solid #0d6efd;
    }

    .map-info-popup {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 10px 16px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        z-index: 999;
        text-align: center;
        animation: fadeIn 0.3s ease;
    }

    @@keyframes fadeIn {
        from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
</style>

@code {
    [Parameter]
    public EventCallback<Guid> OnMpaSelected { get; set; }

    [Parameter]
    public Guid? SelectedMpaId { get; set; }

    [Parameter]
    public bool ShowLegend { get; set; } = true;

    [Parameter]
    public bool ShowFishingEvents { get; set; } = false;

    [Parameter]
    public DateTime? FishingEventsStartDate { get; set; }

    [Parameter]
    public DateTime? FishingEventsEndDate { get; set; }

    [Parameter]
    public EventCallback<FishingEventDto> OnFishingEventSelected { get; set; }

    private MapControl? _mapControl;
    private Map _map = new();
    private bool _loading = true;
    private bool _showLegend = true;
    private string _selectedMpaName = "";
    private Dictionary<string, MpaGeoJsonFeature> _mpaFeatures = new();
    private Dictionary<string, MRect> _mpaBounds = new();
    private MemoryLayer? _mpaLayer;
    private MemoryLayer? _selectionLayer;
    private MemoryLayer? _fishingEventsLayer;
    private FishingEventDto? _selectedFishingEvent;
    private List<FishingEventDto> _fishingEvents = new();
    private bool _fishingEventsLoaded = false;

    protected override async Task OnInitializedAsync()
    {
        _showLegend = ShowLegend;
        InitializeMap();
        await LoadMpaDataAsync();
        _loading = false;
    }

    protected override async Task OnParametersSetAsync()
    {
        // When SelectedMpaId changes from parent, zoom to that MPA
        if (SelectedMpaId.HasValue && _mpaBounds.ContainsKey(SelectedMpaId.Value.ToString()))
        {
            ZoomToMpa(SelectedMpaId.Value.ToString());
            UpdateSelectionHighlight(SelectedMpaId.Value.ToString());
        }

        // Handle fishing events layer toggle
        if (ShowFishingEvents && !_fishingEventsLoaded)
        {
            await LoadFishingEventsAsync();
        }
        else if (!ShowFishingEvents && _fishingEventsLayer != null)
        {
            _map.Layers.Remove(_fishingEventsLayer);
            _fishingEventsLayer = null;
            _fishingEventsLoaded = false;
            _selectedFishingEvent = null;
        }
    }

    private void InitializeMap()
    {
        // Add OpenStreetMap tile layer as base
        _map.Layers.Add(OpenStreetMap.CreateTileLayer());

        // Center on Bahamas (longitude -77.5, latitude 24.5)
        var (x, y) = SphericalMercator.FromLonLat(-77.5, 24.5);
        var bahamasCenter = new MPoint(x, y);

        // Set initial viewport
        _map.Navigator.CenterOnAndZoomTo(bahamasCenter, _map.Navigator.Resolutions[7]);

        // Configure navigator
        _map.Navigator.RotationLock = true;

        // Subscribe to map info events for click handling
        _map.Info += OnMapInfo;
    }

    private void OnMapInfo(object? sender, MapInfoEventArgs e)
    {
        // Clear previous selections
        _selectedFishingEvent = null;

        // Check fishing events layer first (it's on top)
        if (_fishingEventsLayer != null && ShowFishingEvents)
        {
            var fishingInfo = e.GetMapInfo(new[] { _fishingEventsLayer });
            if (fishingInfo?.Feature != null)
            {
                var feature = fishingInfo.Feature;
                if (feature["eventId"] is string eventId)
                {
                    _selectedFishingEvent = _fishingEvents.FirstOrDefault(evt => evt.EventId == eventId);
                    if (_selectedFishingEvent != null)
                    {
                        OnFishingEventSelected.InvokeAsync(_selectedFishingEvent);
                        _selectedMpaName = ""; // Clear MPA selection
                        StateHasChanged();
                        return;
                    }
                }
            }
        }

        // Check MPA layer
        if (_mpaLayer == null) return;

        var mapInfo = e.GetMapInfo(new[] { _mpaLayer });
        if (mapInfo?.Feature != null)
        {
            var feature = mapInfo.Feature;
            if (feature["mpaId"] is string mpaIdStr && Guid.TryParse(mpaIdStr, out var mpaId))
            {
                _selectedMpaName = feature["name"]?.ToString() ?? "";

                // Zoom to the selected MPA
                ZoomToMpa(mpaIdStr);

                // Update selection highlight
                UpdateSelectionHighlight(mpaIdStr);

                // Notify parent component
                OnMpaSelected.InvokeAsync(mpaId);

                StateHasChanged();
            }
        }
        else
        {
            // Clicked on empty area - clear selection
            _selectedMpaName = "";
            ClearSelectionHighlight();
            StateHasChanged();
        }
    }

    private void ZoomToMpa(string mpaId)
    {
        if (_mpaBounds.TryGetValue(mpaId, out var bounds))
        {
            // Add some padding around the MPA
            var paddedBounds = bounds.Grow(bounds.Width * 0.2, bounds.Height * 0.2);
            _map.Navigator.ZoomToBox(paddedBounds);
        }
    }

    private void UpdateSelectionHighlight(string mpaId)
    {
        if (_selectionLayer != null)
        {
            _map.Layers.Remove(_selectionLayer);
        }

        if (_mpaFeatures.TryGetValue(mpaId, out var geoFeature))
        {
            try
            {
                var geometry = ParseGeoJsonGeometry(geoFeature.Geometry);
                if (geometry != null)
                {
                    var transformedGeometry = TransformGeometry(geometry);
                    var feature = transformedGeometry.ToFeature();

                    // Apply highlight style
                    feature.Styles.Add(new VectorStyle
                    {
                        Fill = new Brush(Color.FromArgb(64, 255, 255, 0)), // Yellow highlight
                        Outline = new Pen(Color.FromArgb(255, 255, 193, 7), 4), // Thick yellow border
                        Line = new Pen(Color.FromArgb(255, 255, 193, 7), 4)
                    });

                    _selectionLayer = new MemoryLayer
                    {
                        Name = "Selection",
                        Features = new List<IFeature> { feature }
                    };
                    _map.Layers.Add(_selectionLayer);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error creating selection highlight: {ex.Message}");
            }
        }
    }

    private void ClearSelectionHighlight()
    {
        if (_selectionLayer != null)
        {
            _map.Layers.Remove(_selectionLayer);
            _selectionLayer = null;
        }
    }

    private async Task LoadMpaDataAsync()
    {
        try
        {
            var mpas = await Http.GetFromJsonAsync<MpaGeoJsonCollection>("/api/mpas/geojson");

            if (mpas?.Features != null)
            {
                _mpaLayer = CreateMpaLayer(mpas.Features);
                _map.Layers.Add(_mpaLayer);

                // Store features for click handling and bounds calculation
                foreach (var feature in mpas.Features)
                {
                    _mpaFeatures[feature.Id] = feature;
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading MPA data: {ex.Message}");
        }
    }

    private MemoryLayer CreateMpaLayer(List<MpaGeoJsonFeature> features)
    {
        var mpaFeatures = new List<IFeature>();

        foreach (var geoFeature in features)
        {
            try
            {
                // Parse GeoJSON geometry
                var geometry = ParseGeoJsonGeometry(geoFeature.Geometry);
                if (geometry == null) continue;

                // Transform from WGS84 to SphericalMercator
                var transformedGeometry = TransformGeometry(geometry);

                // Calculate bounds for zoom-to functionality
                var envelope = transformedGeometry.EnvelopeInternal;
                _mpaBounds[geoFeature.Id] = new MRect(
                    envelope.MinX, envelope.MinY,
                    envelope.MaxX, envelope.MaxY
                );

                // Create Mapsui feature from geometry
                var feature = transformedGeometry.ToFeature();
                feature["mpaId"] = geoFeature.Id;
                feature["name"] = geoFeature.Properties.Name;
                feature["protectionLevel"] = geoFeature.Properties.ProtectionLevel;

                // Apply style based on protection level
                feature.Styles.Add(CreateMpaStyle(geoFeature.Properties.ProtectionLevel));

                mpaFeatures.Add(feature);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error creating feature for {geoFeature.Properties.Name}: {ex.Message}");
            }
        }

        return new MemoryLayer
        {
            Name = "Marine Protected Areas",
            Features = mpaFeatures
            // In Mapsui v5, layer querying is done via GetMapInfo() with specific layers
        };
    }

    private Geometry? ParseGeoJsonGeometry(JsonElement geometryJson)
    {
        try
        {
            var serializer = GeoJsonSerializer.Create();
            var json = geometryJson.GetRawText();
            using var reader = new System.IO.StringReader(json);
            using var jsonReader = new Newtonsoft.Json.JsonTextReader(reader);
            return serializer.Deserialize<Geometry>(jsonReader);
        }
        catch
        {
            return null;
        }
    }

    private Geometry TransformGeometry(Geometry geometry)
    {
        // Transform from EPSG:4326 (WGS84) to EPSG:3857 (SphericalMercator)
        var coordinates = geometry.Coordinates;
        var transformedCoords = new Coordinate[coordinates.Length];

        for (int i = 0; i < coordinates.Length; i++)
        {
            var (x, y) = SphericalMercator.FromLonLat(coordinates[i].X, coordinates[i].Y);
            transformedCoords[i] = new Coordinate(x, y);
        }

        var factory = new GeometryFactory();

        if (geometry is Polygon)
        {
            var ring = factory.CreateLinearRing(transformedCoords);
            return factory.CreatePolygon(ring);
        }
        else if (geometry is Point)
        {
            return factory.CreatePoint(transformedCoords[0]);
        }

        return geometry;
    }

    private IStyle CreateMpaStyle(string protectionLevel)
    {
        var fillColor = protectionLevel switch
        {
            "NoTake" => Color.FromArgb(128, 220, 53, 69),           // Red with transparency
            "HighlyProtected" => Color.FromArgb(128, 253, 126, 20), // Orange with transparency
            "LightlyProtected" => Color.FromArgb(128, 13, 202, 240), // Cyan with transparency
            _ => Color.FromArgb(128, 108, 117, 125)                  // Gray with transparency
        };

        var strokeColor = protectionLevel switch
        {
            "NoTake" => Color.FromArgb(255, 220, 53, 69),
            "HighlyProtected" => Color.FromArgb(255, 253, 126, 20),
            "LightlyProtected" => Color.FromArgb(255, 13, 202, 240),
            _ => Color.FromArgb(255, 108, 117, 125)
        };

        return new VectorStyle
        {
            Fill = new Brush(fillColor),
            Outline = new Pen(strokeColor, 2),
            Line = new Pen(strokeColor, 2)
        };
    }

    private async Task LoadFishingEventsAsync()
    {
        try
        {
            var start = FishingEventsStartDate ?? DateTime.UtcNow.AddDays(-30);
            var end = FishingEventsEndDate ?? DateTime.UtcNow;

            var events = await Http.GetFromJsonAsync<List<FishingEventDto>>(
                $"/api/vessels/fishing-events/bahamas?startDate={start:O}&endDate={end:O}");

            if (events != null && events.Count > 0)
            {
                _fishingEvents = events;
                _fishingEventsLayer = CreateFishingEventsLayer(events);
                _map.Layers.Add(_fishingEventsLayer);
                _fishingEventsLoaded = true;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading fishing events: {ex.Message}");
        }
    }

    private MemoryLayer CreateFishingEventsLayer(List<FishingEventDto> events)
    {
        var features = new List<IFeature>();
        var factory = new GeometryFactory();

        foreach (var evt in events)
        {
            try
            {
                var (x, y) = SphericalMercator.FromLonLat(evt.Longitude, evt.Latitude);
                var point = factory.CreatePoint(new Coordinate(x, y));
                var feature = point.ToFeature();

                feature["eventId"] = evt.EventId;
                feature["vesselId"] = evt.VesselId;
                feature["startTime"] = evt.StartTime;

                feature.Styles.Add(CreateFishingEventStyle(evt));
                features.Add(feature);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error creating fishing event feature: {ex.Message}");
            }
        }

        return new MemoryLayer
        {
            Name = "Fishing Events",
            Features = features
        };
    }

    private IStyle CreateFishingEventStyle(FishingEventDto evt)
    {
        var daysAgo = (DateTime.UtcNow - evt.StartTime).TotalDays;
        Color color;

        if (daysAgo < 7)
            color = Color.FromArgb(220, 220, 53, 69);    // Red - recent
        else if (daysAgo < 14)
            color = Color.FromArgb(220, 253, 126, 20);  // Orange
        else if (daysAgo < 30)
            color = Color.FromArgb(220, 255, 193, 7);   // Yellow
        else
            color = Color.FromArgb(150, 108, 117, 125); // Gray - older

        return new SymbolStyle
        {
            Fill = new Brush(color),
            Outline = new Pen(Color.White, 1),
            SymbolScale = 0.4,
            SymbolType = SymbolType.Ellipse
        };
    }

    public void Dispose()
    {
        _map.Info -= OnMapInfo;
    }

    // GeoJSON DTOs for deserialization
    public class MpaGeoJsonCollection
    {
        public string Type { get; set; } = "FeatureCollection";
        public List<MpaGeoJsonFeature> Features { get; set; } = [];
    }

    public class MpaGeoJsonFeature
    {
        public string Type { get; set; } = "Feature";
        public string Id { get; set; } = "";
        public JsonElement Geometry { get; set; }
        public MpaProperties Properties { get; set; } = new();
    }

    public class MpaProperties
    {
        public string Name { get; set; } = "";
        public string ProtectionLevel { get; set; } = "";
        public string IslandGroup { get; set; } = "";
        public double AreaSquareKm { get; set; }
    }

    // Fishing Event DTO for deserialization
    public class FishingEventDto
    {
        public string EventId { get; set; } = "";
        public string VesselId { get; set; } = "";
        public double Longitude { get; set; }
        public double Latitude { get; set; }
        public DateTime StartTime { get; set; }
        public DateTime? EndTime { get; set; }
        public double? DurationHours { get; set; }
        public string? EventType { get; set; }
    }
}
